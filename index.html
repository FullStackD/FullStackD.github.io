<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=5.1.4"><link rel="mask-icon" href="/favicon.ico?v=5.1.4" color="#222"><meta name="keywords" content="Hexo, NexT, Blog"><meta name="description" content="Stay young, Stay hungry, Stay foolish."><meta property="og:type" content="website"><meta property="og:title" content="不忘初心"><meta property="og:url" content="http://yoursite.com/index.html"><meta property="og:site_name" content="不忘初心"><meta property="og:description" content="Stay young, Stay hungry, Stay foolish."><meta property="og:locale" content="zh-Hans"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="不忘初心"><meta name="twitter:description" content="Stay young, Stay hungry, Stay foolish."><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/"><title>不忘初心</title></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">不忘初心</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">少年,专心练剑吧</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i><br> 书单</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/27/《滴滴服务端团队之稳定性规范》切身体会/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2020/06/27/《滴滴服务端团队之稳定性规范》切身体会/" itemprop="url">《滴滴服务端团队之稳定性规范》切身体会</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-27T12:34:39+08:00">2020-06-27</time></span></div></header><div class="post-body" itemprop="articleBody"><p>这里谈谈一些在实际开发中遇到的几个问题。</p><h2 id="2-3-监控告警"><a href="#2-3-监控告警" class="headerlink" title="2.3.监控告警"></a>2.3.监控告警</h2><ol><li>【强制】线上服务机器必须有基础监控报警，包含CPU、IO、内存、磁盘、coredump、端口</li><li>【强制】线上服务必须有基础的服务监控，包括接口qps、fatal数量、耗时</li></ol><blockquote><p>基础监控报警，目前可能未配置报警。服务超时、异常等报警有配置。</p></blockquote><h2 id="2-4-变更管理"><a href="#2-4-变更管理" class="headerlink" title="2.4.变更管理"></a>2.4.变更管理</h2><ol><li>【强制】任何一级服务变更，均需要走灰度发布机制</li><li>【强制】任何一级服务变更，包括服务变更、配置变更，均需要有相应的回滚预案，保证变更异常时可以快速回退</li></ol><blockquote><ol><li>上线中都需要单点部署后，再全量部署（每个节点有部署间隔）</li><li>上线要检查变更列表，如jar包发布，配置变更，服务调用增加等等是否已完成。 多个服务上线，制定上线顺序以及相应的回滚方案。</li></ol></blockquote><hr><h5 id="反模式3-1-9-没有对非核心流程弱依赖化"><a href="#反模式3-1-9-没有对非核心流程弱依赖化" class="headerlink" title="反模式3.1.9 没有对非核心流程弱依赖化"></a>反模式3.1.9 没有对非核心流程弱依赖化</h5><p>【实例】</p><blockquote><p>没有对流程进行弱依赖化，导致系统整体上比较脆弱，每个依赖单元故障都会导致整个业务瘫痪</p></blockquote><p>【解决方案】</p><blockquote><p>定期对系统的流程进行梳理，最小系统化，非必须流程尽量弱依赖化。</p><p>在项目中，某个流程会调用二方或三方接口，如果该接口出现了异常，也不会影响主流程的结果。例如：不能影响库存服务异常，而导致整个订单查询异常。</p></blockquote><h5 id="反模式3-4-1-代码搭车上线"><a href="#反模式3-4-1-代码搭车上线" class="headerlink" title="反模式3.4.1 代码搭车上线"></a>反模式3.4.1 代码搭车上线</h5><p>【实例】</p><blockquote><p>由于缺乏有效的代码修改管理机制，某产品线由于代码搭车上线，出现过多次线上故障<br>并且由于变更时涉及的修改比较多，导致问题定位和追查时非常困难</p></blockquote><p>【解决方案】</p><blockquote><p>建立严格的代码管理机制，严禁代码搭车上线，保证任何时刻主干没有未上线验证的代码</p><p>这一点其实还蛮多人用的（笑）。个人认为修复一些简单的线上Bug还是可以搭车上线的。</p></blockquote><h5 id="反模式3-4-7-变更没有经过严格的测试"><a href="#反模式3-4-7-变更没有经过严格的测试" class="headerlink" title="反模式3.4.7 变更没有经过严格的测试"></a>反模式3.4.7 变更没有经过严格的测试</h5><p>【实例】</p><blockquote><p>变更较小，感觉没有必要进行测试，结果出现低级错误，导致故障</p></blockquote><p>【解决方案】</p><blockquote><p>任何变更都要测试、double check，修改一行代码，也可能导致线上的稳定性故障</p><p>目前上线流程，都要经过冒烟测试、QA测试、沙箱测试才能上线，且上线后第一时间验证。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[1] <a href="https://mp.weixin.qq.com/s/gVNKibDQ6UsX_q8_CHvg1A" target="_blank" rel="noopener">五年磨一剑,服务端团队呕心力作之稳定性规范</a></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/27/Code Review小记/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2020/06/27/Code Review小记/" itemprop="url">Code Review小记</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-27T12:22:48+08:00">2020-06-27</time></span></div></header><div class="post-body" itemprop="articleBody"><p>这里写一下最近在Code Review中遇到的一些问题。</p><ol><li><p>遵循良好的日志规范。</p><ul><li>例如：日志打印logStr act=函数名 msg=信息 入参={} 出参{}</li></ul></li><li><p>使用Objects.nonNull, Objects.isNull，CollectionUtils来判断对象是否为空，集合是否为空（增强代码可读性）</p></li><li><p>重复调用二方服务，同一个类中抽取统一的方法或抽取到另外一个Service中。</p></li><li><p>校验请求是否success，数据是否为Null，再使用数据，否则打印日志</p></li><li><p>不要轻易修改公用库的DTO，可能会影响其他服务调用方</p><p>若A服务和B服务都依赖于C服务，那么因为A服务的时间格式要调整，那么尽量在A服务中修改，不要在C服务中修改，避免影响其他的服务。同时，C服务尽量提供时间戳或Code及枚举类这样的形式便于A服务和B服务定制化结果。</p></li><li><p>调外部接口，必须使用try catch捕获异常，并正确打印日志</p></li><li><p>接口要编写接口文档</p><ul><li>入参及必要的参数说明</li><li>出参</li><li>请求示例</li><li>返回示例</li></ul></li><li><p>复用已有代码时，要review，确保原先的代码没有问题，避免使用原代码出现问题。</p></li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/27/吾日三省吾身/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2020/06/27/吾日三省吾身/" itemprop="url">吾日三省吾身</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-27T12:12:50+08:00">2020-06-27</time></span></div></header><div class="post-body" itemprop="articleBody"><p>最近不记得在哪里看到这样一段话， 觉得言之有理便收藏了下来。</p><blockquote><p>可以试一下这样的一个思维训练：<br>我现在在做的事情，换一个大佬来，能做的比我更好吗？<br>如果可以，那最可能是在哪方面做的比我好？<br>如果知道哪方面，那现在的我可以去做的更好吗？<br>如果想不出答案，就多和别人，和主管，和大牛同事讨论这几个问题，往往都能发现即便在开发的日常业务有也蕴含着无限的可能性。</p></blockquote><p>当然这里不是我们去思考就可以解决问题，但是思考的过程很重要，会产生无限的可能性。</p><p>这里举一些例子：</p><ol><li>开发中使用MQ，对它的重试机制了解吗？知道在哪里配置吗？</li><li>在微服务架构中，持久层也是一个单独的服务，对于事务处理，项目中有用到分布式事务吗？如果因为业务原因没有强一致性需求，没有使用，那么知道如果要用的话该如何配置吗？具体使用的方案又是哪一种呢</li><li>Apollo配置中心是如何实现配置发布即生效呢？<ol><li>实时读取Apollo配置中心的配置</li><li>参数初始化时，添加监听器</li></ol></li><li>有了解过服务中的埋点有哪些吗？日志埋点？性能统计等等？</li><li>项目中使用的RPC框架有具体了解过吗？</li><li>分布式调度平台XXL-JOB的一些文档有没有抽时间看呢？</li></ol><p>思考-&gt;发现问题-&gt;解决问题-&gt;再思考。不断的进行这样的过程，才能提高自己的水平。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/27/开发小记-2/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2020/06/27/开发小记-2/" itemprop="url">开发小记-2</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-27T11:15:05+08:00">2020-06-27</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/开发小记/" itemprop="url" rel="index"><span itemprop="name">开发小记</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="关于Jedis的坑"><a href="#关于Jedis的坑" class="headerlink" title="关于Jedis的坑"></a>关于Jedis的坑</h2><p>今天分享一个白衣大大在微博中说明的关于Jedis的坑</p><blockquote><p>“基础架构部之jedis中坑人的maxIdle参数”，jedis用的是apache commons pools做连接池。</p><p>连接池大小由minIdle，maxIdle，maxTotal三个参数控制。头一个和末一个好理解，就是连接池的最小和最大值，而maxIdle就比较坑人了，连接用完后，如果连接池小于maxIdle，就放回连接池，大于就直接扔掉。</p><p>又有这么一个应用，把三个值分别设为2，10，40，当压力来了，10个连接不够用了，就要频繁创连接，执行完一个命令就丢掉，下一个命令再创，再丢，cps(new connection per second) 的值，等于没有在原来10条连接里处理的qps，我们称为连接风暴。</p><p>这时候redis可遭罪了，单线程又要处理命令，又要处理连接创建，两头忙两头不是人（redis 6独立的io线程可以改善么？）</p><p>所以，maxIdle应该就和maxTotal同一个值，别开放出去让人配了。</p><p>另外一开始池里也没有minIdle所指定的最少连接数，可以应用启动时做一下预热。</p></blockquote><p>当时看到这个以后，由于我们的项目中也在用Jedis于是去检查了一下参数是如何设置的，maxIdle确实和maxTotal同一个值，但是配置并不规范，连接池的参数都写在了代码中，而非配置文件。</p><hr><h2 id="Redis-6之I-O多线程"><a href="#Redis-6之I-O多线程" class="headerlink" title="Redis 6之I/O多线程"></a>Redis 6之I/O多线程</h2><p>这里看到白衣大大提到，Redis 6的I/O多线程，也顺便了解一下。</p><h3 id="Redis-6-0-之前为什么一直不使用多线程？"><a href="#Redis-6-0-之前为什么一直不使用多线程？" class="headerlink" title="Redis 6.0 之前为什么一直不使用多线程？"></a>Redis 6.0 之前为什么一直不使用多线程？</h3><blockquote><p>使用了单线程后，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。</p><p>Redis 通过 AE 事件模型以及 IO 多路复用等技术，处理性能非常高，因此没有必要使用多线程。</p><p>单线程机制使得 Redis 内部实现的复杂度大大降低，Hash 的惰性 Rehash、Lpush 等等 “线程不安全” 的命令都可以无锁进行。</p></blockquote><h3 id="Redis-6-0-为什么要引入多线程呢？"><a href="#Redis-6-0-为什么要引入多线程呢？" class="headerlink" title="Redis 6.0 为什么要引入多线程呢？"></a>Redis 6.0 为什么要引入多线程呢？</h3><blockquote><p>之前的段落说了，Redis 的瓶颈并不在 CPU，而在内存和网络。</p><p>内存不够的话，可以加内存或者做数据结构优化和其他优化等，但网络的性能优化才是大头，网络 IO 的读写在 Redis 整个执行期间占用了大部分的 CPU 时间，如果把网络处理这部分做成多线程处理方式，那对整个 Redis 的性能会有很大的提升。</p><p>优化方向：</p><ul><li>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式。</li><li>使用多线程充分利用多核，典型的实现比如 Memcached。</li></ul><p>所以总结起来，Redis 支持多线程主要就是两个原因：</p><ul><li>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核。</li><li>多线程任务可以分摊 Redis 同步 IO 读写负荷。</li></ul></blockquote><h3 id="Redis-6-0-默认是否开启了多线程？"><a href="#Redis-6-0-默认是否开启了多线程？" class="headerlink" title="Redis 6.0 默认是否开启了多线程？"></a>Redis 6.0 默认是否开启了多线程？</h3><blockquote><p>否，在conf文件进行配置</p><p>io-threads-do-reads yes</p><p>io-threads 线程数</p></blockquote><h3 id="Redis-6-0-多线程的实现机制？"><a href="#Redis-6-0-多线程的实现机制？" class="headerlink" title="Redis 6.0 多线程的实现机制？"></a>Redis 6.0 多线程的实现机制？</h3><p><img src="https://i.loli.net/2020/06/27/dPoVp75l61FWDrz.png" alt="1712130-20200516174816219-1469215261.png"></p><p><strong><em>流程简述如下\</em></strong>：</p><ul><li>主线程负责接收建立连接请求，获取 Socket 放入全局等待读处理队列。</li><li>主线程处理完读事件之后，通过 RR（Round Robin）将这些连接分配给这些 IO 线程。</li><li>主线程阻塞等待 IO 线程读取 Socket 完毕。</li><li>主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行。</li><li>主线程阻塞等待 IO 线程将数据回写 Socket 完毕。</li><li>解除绑定，清空等待队列。</li></ul><p><img src="https://i.loli.net/2020/06/27/134htJwXAypduBm.png" alt="1712130-20200516174905348-1186276910.png"></p><p>该设计有如下特点：</p><ul><li>IO 线程要么同时在读 Socket，要么同时在写，不会同时读或写。</li><li>IO 线程只负责读写 Socket 解析命令，不负责命令处理。</li></ul><p>这样看来的话，还是不能解决Jedis配置在maxIdle&lt;maxTotal时，导致的频繁创建和执行命令的问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[1] <a href="https://weibo.com/1728555142/J7c6B1q35" target="_blank" rel="noopener">https://weibo.com/1728555142/J7c6B1q35</a></li><li>[2] <a href="https://www.cnblogs.com/gz666666/p/12901507.html" target="_blank" rel="noopener">Redis 6.0 多线程重磅发布！！！</a></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/26/开发小记-1/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2020/06/26/开发小记-1/" itemprop="url">开发小记（一）</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-26T22:12:16+08:00">2020-06-26</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/开发小记/" itemprop="url" rel="index"><span itemprop="name">开发小记</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>从”零”开始已经一个月了，总结一下自己在这段时间学到的东西吧。 虽然很基础，但是总要有一个慢慢积累的过程。</p><h2 id="Java8流处理语法"><a href="#Java8流处理语法" class="headerlink" title="Java8流处理语法"></a>Java8流处理语法</h2><p>这里简单介绍几个我用过的语法。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出entity中的某个属性</span></span><br><span class="line">List&lt;String&gt; studentNames = list.stream().map(student -&gt; student.getName()).collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 取出符合条件的实体</span></span><br><span class="line">List&lt;Student&gt; students = list.stream().filter(student -&gt; student.getAge() &gt;= <span class="number">18</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更简洁的方式遍历集合(注意，若list为null，会抛出NPE）</span></span><br><span class="line">list.forEach(student -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h2 id="Optional语法"><a href="#Optional语法" class="headerlink" title="Optional语法"></a>Optional语法</h2><p>Optional 类主要解决的问题是空指针异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据是否为空，决定函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getGender</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == student) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unkown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> student.getGender();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Optional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getGender</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(student).map(u -&gt; u.getGender()).orElse(<span class="string">"Unkown"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Optional中orElse的源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ifPresent避免判空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">    Optional.ofNullable(student).ifPresent(u -&gt;  System.out.println(<span class="string">"The student name is : "</span> + u.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Optional开发时要注意正确使用Optional的“姿势”，谨慎使用isPresent()和get()方法，尽量多使用map()、filter()、orElse()等方法来发挥Optional的作用。</p><h2 id="同事写AOP时遇到的一个小问题"><a href="#同事写AOP时遇到的一个小问题" class="headerlink" title="同事写AOP时遇到的一个小问题"></a>同事写AOP时遇到的一个小问题</h2><p>在某个需求中，需要对一些接口中的uid进行鉴权。由于不同的方法可能对应不同的权限码，所以实现如下：</p><p>在实现了某个接口的类中需要鉴权的方法上，添加了注解 <code>@AuthType(AuthCode = AuthEnum.UserType)</code></p><p>在AOP处理的类中取该注解，但是遇到一个问题，取不到该注解。</p><p>这里就需要谈谈AOP的实现原理了，众所周知，AOP是通过动态代理的方式来实现的，有JDK动态代理和cglib两种方式。</p><ul><li>JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。</li><li>CGLIB动态代理，可以在运行时动态的生成某个类的子类。通过字节码技术生成，创建速度慢，执行不需要反射。生成的类会在Java的永久代中。</li></ul><p>看到这里可能已经有人明白了，Spring AOP默认使用的是JDK动态代理的方式，在实现类中加的注解，在切面中自然取不到了。</p><p>解决方案：当我们需要强制使用CGLIB来实现AOP的时候，需要配置<code>spring.aop.proxy-target-class=true</code>或<code>@EnableAspectJAutoProxy(proxyTargetClass = true</code>)</p><h2 id="为什么插件自动给变量加final"><a href="#为什么插件自动给变量加final" class="headerlink" title="为什么插件自动给变量加final"></a>为什么插件自动给变量加final</h2><p>最近在原来的类中编写类的代码的时候，发现由于IDEA某个插件，会自动给有初始值且并未修改过的全局变量加final。</p><p>由此就考虑到一个问题，这样加final的好处是什么呢？我们来看看两者的区别。</p><p>这里可以使用IDEA的【ByteCode Viewer】插件来查看类的字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处为不加final的版本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是加final和不加final关键字的两个类的字节码的区别。</p><p><img src="https://i.loli.net/2020/06/27/zaicv1JhXnDT5gx.png" alt="微信截图_20200627010744.png"></p><p>这里看到有一段<code>static &lt;clinit&gt;</code>的指令，即类加载初始化过程中的 <code>(clinit)</code> 方法，也就是静态变量赋值以及静态代码块中的代码。</p><p>这里就需要提一下<strong>类加载过程</strong>了。众所周知，类加载过程分为<strong>加载、验证、准备、解析、初始化</strong>这五步。</p><ol><li><p>未加final关键字时。在准备阶段为类变量（static修饰的）分配内存并设置类变量初始值（值数据类型的零值，对于int来说是0）。在初始化阶段，执行类构造器<code>&lt;clinit&gt;</code>方法（由编译器自动收集类中所有<strong>类变量</strong>的赋值动作和静态语句块中的语句合并产生）</p><blockquote><p>虚拟机会保证一个类的<code>&lt;clinit&gt;</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;</code>方法完毕。</p></blockquote></li><li><p>加了final关键字后。在准备阶段，虚拟机就会将num赋值为6.</p></li></ol><p>这里还需要提一个事情，就是<strong>类加载的时机</strong>。《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。 但是对于<strong>初始化阶段</strong>，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证准备自然需要在此之前开始）：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行初始化，则需要先触发其初始化阶段。典型场景：使用new关键字实例化对象时、读取或设置一个类型的静态字段、调用一个类型的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候。</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要自定一个要执行的主类，虚拟机会先初始化这个主类。</li><li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><p>所以这里就大概知道结论了。</p><ul><li><p>对于Spring管理的类，需要在JVM启动时，实例化对象并注入Spring容器。添加final关键字会使得服务启动相对来说更快。</p></li><li><p>对于都是静态方法的工具类，会在使用静态方法的时候，初始化类。此时JVM还会加锁，保证只会有一个线程去执行这个类的<code>&lt;clinit&gt;</code>方法。添加final关键字会避免这个过程，在并发情况下提高了性能。</p></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/P1567-统计天数/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2020/03/03/P1567-统计天数/" itemprop="url">P1567 统计天数</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-03T19:43:02+08:00">2020-03-03</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>炎热的夏日，KC 非常的不爽。他宁可忍受北极的寒冷，也不愿忍受厦门的夏天。最近，他开始研究天气的变化。他希望用研究的结果预测未来的天气。<br>经历千辛万苦，他收集了连续 N(1 ≤ <em>N</em>≤ 10^6) 的最高气温数据。<br>现在，他想知道最高气温一直上升的最长连续天数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 1 行：一个整数 N 。1≤<em>N</em>≤10^6<br>第 2 行：N个空格隔开的整数，表示连续 N 天的最高气温。0 ≤ 最高气温 ≤10^9。</p><div class="post-button text-center"> <a class="btn" href="/2020/03/03/P1567-统计天数/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/使用覆盖索引优化SQL语句/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2020/03/03/使用覆盖索引优化SQL语句/" itemprop="url">使用覆盖索引优化SQL语句</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-03T19:41:00+08:00">2020-03-03</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p> 某同学写了以下的查询sql，通过每次对limit的offset进行增大，取到不同批数据做处理，比如，第一次是limit 0,100，第二次是limit100,100，现在该同学发现，随着offset的增大，sql变得越来越慢，这个时候让你进行优化，你会怎么做呢？</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">'account'</span>&#123;</span><br><span class="line">    <span class="string">'id'</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    <span class="string">'account'</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'balance'</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="string">'id'</span>)</span><br><span class="line">&#125;<span class="keyword">engine</span>=<span class="keyword">innoDB</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">limit</span> ?,?</span><br></pre></td></tr></table></figure><div class="post-button text-center"> <a class="btn" href="/2020/03/03/使用覆盖索引优化SQL语句/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/24/用Python爬取考研调剂信息/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2020/02/24/用Python爬取考研调剂信息/" itemprop="url">用Python爬取考研调剂信息</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-24T15:38:21+08:00">2020-02-24</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/爬虫/" itemprop="url" rel="index"><span itemprop="name">爬虫</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><ol><li>未加请求头时，会返回404，故添加header。</li><li>分析网页<code>http://muchong.com/f-430-1</code>为第一页，<code>http://muchong.com/f-430-2</code>为第二页</li><li>使用utf-8对网页内容解码时，会出现乱码。查看网页源代码， <code>charset=&quot;gbk&quot;</code> ，故改为gbk编码。</li><li>通过查看元素得到标题，时间的标签和class。</li><li>写入markdown文件，方便打开查看。</li></ol><div class="post-button text-center"> <a class="btn" href="/2020/02/24/用Python爬取考研调剂信息/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/29/Markdown中使用MathJax/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2019/01/29/Markdown中使用MathJax/" itemprop="url">Markdown中使用MathJax</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-29T22:34:42+08:00">2019-01-29</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/其他/" itemprop="url" rel="index"><span itemprop="name">其他</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><ol><li>希腊字母</li></ol><div class="table-container"><table><thead><tr><th>显示</th><th>公式</th><th>显示</th><th>公式</th></tr></thead><tbody><tr><td><script type="math/tex">\alpha</script></td><td>\alpha</td><td><script type="math/tex">\beta</script></td><td>\beta</td></tr><tr><td><script type="math/tex">\gamma</script></td><td>\gamma</td><td><script type="math/tex">\delta</script></td><td>\delta</td></tr><tr><td><script type="math/tex">\epsilon</script></td><td>\epsilon</td><td><script type="math/tex">\zeta</script></td><td>\zeta</td></tr><tr><td><script type="math/tex">\eta</script></td><td>\eta</td><td><script type="math/tex">\theta</script></td><td>\theta</td></tr><tr><td><script type="math/tex">\iota</script></td><td>\iota</td><td><script type="math/tex">\kappa</script></td><td>\kappa</td></tr><tr><td><script type="math/tex">\lambda</script></td><td>\lambda</td><td><script type="math/tex">\mu</script></td><td>\mu</td></tr><tr><td><script type="math/tex">\nu</script></td><td>\nu</td><td><script type="math/tex">\xi</script></td><td>\xi</td></tr><tr><td><script type="math/tex">\pi</script></td><td>\pi</td><td><script type="math/tex">\rho</script></td><td>\rho</td></tr><tr><td><script type="math/tex">\sigma</script></td><td>\sigma</td><td><script type="math/tex">\tau</script></td><td>\tau</td></tr><tr><td><script type="math/tex">\upsilon</script></td><td>\upsilon</td><td><script type="math/tex">\phi</script></td><td>\phi</td></tr><tr><td><script type="math/tex">\chi</script></td><td>\chi</td><td><script type="math/tex">\psi</script></td><td>\psi</td></tr><tr><td><script type="math/tex">\omega</script></td><td>\omega</td><td></td></tr></tbody></table></div><div class="post-button text-center"> <a class="btn" href="/2019/01/29/Markdown中使用MathJax/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/谈谈尾递归和矩阵快速幂/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2019/01/18/谈谈尾递归和矩阵快速幂/" itemprop="url">谈谈尾递归和矩阵快速幂</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-18T10:35:17+08:00">2019-01-18</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h1><p>如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。例如：<code>return f(n-1);</code>而 <code>return n + f(n-1) ;</code>则不是。</p><p>以求阶乘为例，一般写法如下,如果这个函数调用的深度太深，很容易会有爆栈的危险。</p><div class="post-button text-center"> <a class="btn" href="/2019/01/18/谈谈尾递归和矩阵快速幂/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/07/《从0到1，全面学透区块链》笔记/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2019/01/07/《从0到1，全面学透区块链》笔记/" itemprop="url">《从0到1，全面学透区块链》笔记</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-07T18:31:05+08:00">2019-01-07</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="区块链名词解释"><a href="#区块链名词解释" class="headerlink" title="区块链名词解释"></a>区块链名词解释</h3><ul><li><p>矿工</p><p>给比特币网络提交的转账的请求，需要等矿工来打包处理。</p></li><li><p>挖矿</p><p>争相计算获得记账权的过程形象地比喻成“挖矿”，竞争挖矿的人或组织，叫”矿工“。</p></li><li><p>算力</p><p>可简单理解为计算能力。每秒能做多少次哈希碰撞，就是其”算力“的代表。</p><div class="post-button text-center"> <a class="btn" href="/2019/01/07/《从0到1，全面学透区块链》笔记/" rel="contents">阅读全文 &raquo;</a></div></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/机器学习笔记第1周/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2019/01/06/机器学习笔记第1周/" itemprop="url">机器学习笔记第1周</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-06T11:32:43+08:00">2019-01-06</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul><li><p><strong>机器学习</strong>是什么？</p><p>Tom Mitchell对于机器学习的<strong>定义</strong>：一个程序被认为能从经验 E 中学习，解决任务 T，达到性能度量值P，当且仅当，有了经验 E 后，经过 P 评判，程序在处理 T 时的性能有所提升。</p></li></ul><ul><li><p><strong>监督学习</strong></p><p>监督学习中的数据中是提前做好了分类的信息的，如垃圾邮件检测中，他的训练样本是提前存在分类的信息，也就是对垃圾邮件和非垃圾邮件的标记信息。监督学习中，他的训练样本中是同时包含有特征和标签信息的。监督学习中，比较典型的问题就是<code>分类问题(Classfication)</code>和<code>回归问题(Regression)</code>。它们两者最主要的特点就是分类算法中的标签是离散的值，就像上面说的邮件分类问题中的标签为{1, -1},分别表示了垃圾邮件和非垃圾邮件，而回归算法中的标签值一般是连续的值，如预测一个人的年龄，一般要根据身高、性别、体重等标签，这是因为年龄是连续的正整数。</p><div class="post-button text-center"> <a class="btn" href="/2019/01/06/机器学习笔记第1周/" rel="contents">阅读全文 &raquo;</a></div></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/06/Java多线程-工具篇-BlockingQueue/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/09/06/Java多线程-工具篇-BlockingQueue/" itemprop="url">Java多线程-工具篇-BlockingQueue</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-06T14:49:53+08:00">2016-09-06</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p><strong>来自：jack.yujun - 博客园</strong><br><strong>链接：<a href="http://www.cnblogs.com/jackyuj/archive/2010/11/24/1886553.html" target="_blank" rel="noopener">http://www.cnblogs.com/jackyuj/archive/2010/11/24/1886553.html</a></strong></p><ul><li><p><strong>前言：</strong></p><p> 在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。</p></li></ul><div class="post-button text-center"> <a class="btn" href="/2016/09/06/Java多线程-工具篇-BlockingQueue/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/23/数据库连接池的实现原理/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/08/23/数据库连接池的实现原理/" itemprop="url">数据库连接池的实现原理</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-23T19:53:36+08:00">2016-08-23</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="一、为什么在连接数据库时要使用连接池"><a href="#一、为什么在连接数据库时要使用连接池" class="headerlink" title="一、为什么在连接数据库时要使用连接池"></a>一、为什么在连接数据库时要使用连接池</h2><p> 数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的 性能低下。 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。 连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。</p><div class="post-button text-center"> <a class="btn" href="/2016/08/23/数据库连接池的实现原理/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/16/机器人的运动范围/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/08/16/机器人的运动范围/" itemprop="url">机器人的运动范围</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-16T10:56:53+08:00">2016-08-16</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>地上有一个<code>m行</code>和<code>n列</code>的方格。一个机器人从坐标<code>0,0</code>的格子开始移动，每一次只能向<code>左，右，上，下</code>四个方向移动一格，但是不能进入<code>行坐标</code>和<code>列坐标</code>的<code>数位之和大于k</code>的格子。</p><p>例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><div class="post-button text-center"> <a class="btn" href="/2016/08/16/机器人的运动范围/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/11/HashMap源码分析/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/08/11/HashMap源码分析/" itemprop="url">HashMap源码分析(1.7 + 1.8)</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-11T12:37:51+08:00">2016-08-11</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/源码分析/" itemprop="url" rel="index"><span itemprop="name">源码分析</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="签名（signature）"><a href="#签名（signature）" class="headerlink" title="签名（signature）"></a>签名（signature）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>可以看到<code>HashMap</code>继承了</p><ul><li>标记接口<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Cloneable.html" target="_blank" rel="noopener">Cloneable</a>，用于表明<code>HashMap</code>对象会重写<code>java.lang.Object#clone()</code>方法，HashMap实现的是浅拷贝（shallow copy）。</li><li>标记接口<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/io/Serializable.html" target="_blank" rel="noopener">Serializable</a>，用于表明<code>HashMap</code>对象可以被序列化</li></ul><div class="post-button text-center"> <a class="btn" href="/2016/08/11/HashMap源码分析/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/04/原型模式/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/08/04/原型模式/" itemprop="url">原型模式</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-04T16:46:01+08:00">2016-08-04</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/设计模式/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>在使用原型模式时，我们需要首先创建一个原型对象，再通过复制这个原型对象来创建更多同类型的对象。原型模式的定义如下：</p><p>原型模式的<code>工作原理</code>很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。</p><p>需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。</p><div class="post-button text-center"> <a class="btn" href="/2016/08/04/原型模式/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/04/深复制和浅复制/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/08/04/深复制和浅复制/" itemprop="url">深复制和浅复制</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-04T15:46:01+08:00">2016-08-04</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="浅复制与深复制概念"><a href="#浅复制与深复制概念" class="headerlink" title="浅复制与深复制概念"></a>浅复制与深复制概念</h1><h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><p><code>被复制对象</code>的<code>所有变量</code>都含有与<code>原来的对象</code>相同的值，而所有的对<code>其他对象的引用</code>仍然指向<code>原来的对象</code>。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p><h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><p><code>被复制对象</code>的<code>所有变量</code>都含有与<code>原来的对象</code>相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，<code>深复制</code>把要复制的对象<code>所引用的对象</code>都<code>复制</code>了一遍。</p><div class="post-button text-center"> <a class="btn" href="/2016/08/04/深复制和浅复制/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/24/数组中出现次数超过一半的数字/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/07/24/数组中出现次数超过一半的数字/" itemprop="url">数组中出现次数超过一半的数字</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-24T15:14:46+08:00">2016-07-24</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组 <code>{1, 2, 3, 2, 2, 2, 5, 4, 2}</code> 。由于数字 <code>2</code> 在数组中出现了<code>5</code>次， 超过数组长度的一半，因此输出<code>2</code>。</p><div class="post-button text-center"> <a class="btn" href="/2016/07/24/数组中出现次数超过一半的数字/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/24/最小的k个数/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="Monster"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="不忘初心"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/2016/07/24/最小的k个数/" itemprop="url">最小的k个数</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-24T09:37:51+08:00">2016-07-24</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入n个数，找出其中最小的k个数。例如输入 <code>4、5、1、6、2、7、3、8</code> 这8个数字，则最小的4个数字是 <code>1、2、3、4</code> 。<br>镜像问题：找出最大的k个数问题，思路相同。<br>最简单的思路是把输入的n个整数从小到大排序，排序之后位于最前面的k个数就是最小的k个数。这种思路的时间复杂度是O(nlogn)。</p><div class="post-button text-center"> <a class="btn" href="/2016/07/24/最小的k个数/" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"> <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Monster"><p class="site-author-name" itemprop="name">Monster</p><p class="site-description motion-element" itemprop="description">Stay young, Stay hungry, Stay foolish.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">41</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/fullstackd" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:a516094242@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://example.com/" title="友链1" target="_blank">友链1</a></li><li class="links-of-blogroll-item"> <a href="http://example.com/" title="友链2" target="_blank">友链2</a></li><li class="links-of-blogroll-item"> <a href="http://example.com/" title="友链3" target="_blank">友链3</a></li></ul></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Monster</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script><script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>